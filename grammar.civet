"civet autoConst"

enum Precedence
  Comma = -1
  Function = 1
  Default = 1
  Priority

  Or          // L -> or ??
  And         // L -> and
  Cmp         // L -> == ~= != < > <= >= ~= == <=> instanceof
  Bor         // L -> |
  Bxor        // L -> ~
  Band        // L -> &
  Bshift      // L -> << >>
  Concat      // R -> ..
  Arith       // L -> + -
  ArithDiv    // L -> * / // %
  Unary       // L -> not ! # + - ~
  Power       // R -> ^
  In          // L -> in

  Pipe

  Statement
  Program

module.exports = grammar
  name: "pluto"

  extras: ($) => []
    /[\n]/
    /\s/
  
  rules:
    chunk: ($) => $._expression

    _var: ($) => choice $.identifier,
                        (seq $.prefix_expression, "[", $._expression, "]"),
                        (seq $.prefix_expression, ".", $.identifier)

    _expression: ($) => choice
      $.nil,
      $.boolean,
      $.number,
      $.table,
      $.prefix_expression,
      $.binary_operation,
      $.unary_operation,
      $.new_expression,
      (alias $._increment, $.increment_expression),
      (alias $._pipe, $.pipe_expression)

    prefix_expression: ($) => choice (seq "(", $._expression, ")"),
                                     $.function_call,
                                     $._var

    _explist: ($) => seq $._expression, (anyAmountOf ",", $._expression)

    function_call: ($) => choice (seq $.prefix_expression, $._args),
                                 (seq $.prefix_expression, ":", $.identifier, $._args)

    _args: ($) => choice (seq "(", (optional $._explist), ")"),
                         $.table

    nil: => "nil"
    
    boolean: => choice "true", "false"

    /* from tree-sitter-lua, adjusted a lil bit */
    number: ($) =>
      decimal_digits = /[_0-9]+/
      signed_integer = seq (optional choice "-", "+"), decimal_digits
      decimal_exponent_part = seq (choice "e", "E"), signed_integer

      decimal_integer_literal = choice
        "0",
        seq (optional "0"), /[1-9]/, (optional decimal_digits)

      hex_digits = /[_a-fA-F0-9]+/
      hex_exponent_part = seq (choice "p", "P"), signed_integer

      bin_literal = seq
        (choice "0b", "0B"),
        /[_01]+/

      decimal_literal = choice
        (seq decimal_integer_literal,
             ".",
             (optional decimal_digits),
             (optional decimal_exponent_part)),
        (seq ".",
             decimal_digits,
             (optional decimal_exponent_part)),
        (seq decimal_integer_literal,
             (optional decimal_exponent_part))

      hex_literal = seq
        (choice "0x", "0X"),
        hex_digits,
        (optional seq ".", hex_digits),
        (optional hex_exponent_part)

      token choice decimal_literal, hex_literal, bin_literal

    table: ($) => seq "{", (optional $._fieldlist), "}"

    _fieldlist: ($) => seq $.field, (anyAmountOf $._fieldsep, $.field), optional $._fieldsep

    field: ($) => choice (seq "[", (field "key", $._expression), "]", "=", (field "value", $._expression)),
                         (seq (field "key", $.identifier) , "=", (field "value", $._expression)),
                         $._expression

    _fieldsep: => choice ",", ";"

    new_expression: ($) => seq (plutoKeyword "new"), $.prefix_expression, $._args

    _increment: ($) => seq "++", $.prefix_expression

    _pipe: ($) => seq $.prefix_expression, "|>", $.pipe_function_call, anyAmountOf "|>", $.pipe_function_call

    pipe_function_call: ($) => prec.right Precedence.Pipe,
                                            choice (seq "(", (choice $.prefix_expression, $._expression), ")"),
                                                   (seq $._var, optional $._pipe_args),
                                                   (seq $.prefix_expression, ":", $.identifier, optional $._pipe_args)

    _pipe_args: ($) => seq "|", $._expression, (anyAmountOf ",", $._expression), "|"

    binary_operation: ($) => choice
      ...[
        ["or",  Precedence.Or]
        ["??",  Precedence.Or]
        ["and", Precedence.And]
        ["==",  Precedence.Cmp]
        ["~=",  Precedence.Cmp]
        ["!=",  Precedence.Cmp]
        ["<",   Precedence.Cmp]
        [">",   Precedence.Cmp]
        ["<=",  Precedence.Cmp]
        [">=",  Precedence.Cmp]
        ["<=>", Precedence.Cmp]
        ["instanceof", Precedence.Cmp]
        ["|",  Precedence.Bor]
        ["~",  Precedence.Bxor]
        ["&",  Precedence.Band]
        ["<<", Precedence.Bshift]
        [">>", Precedence.Bshift]
        ["+",  Precedence.Arith]
        ["-",  Precedence.Arith]
        ["*",  Precedence.ArithDiv]
        ["/",  Precedence.ArithDiv]
        ["//", Precedence.ArithDiv]
        ["%",  Precedence.ArithDiv]
        ["in", Precedence.In]
      ].map precedence $, "left",
      ...[
        ["..", Precedence.Concat]
        ["^", Precedence.Power]
      ].map precedence $, "right"

    unary_operation: ($) =>
      prec.left Precedence.Unary, seq (choice
        "not",
        "!",
        "#",
        "+",
        "-",
        "~"
      ), $._expression

    _identifier: => /[a-zA-Z0-9][a-zA-Z0-9]*/
    identifier: ($) => $._identifier

function precedence($, x)
  [op, preced] => prec[x] preced, seq $._expression, op, $._expression

function plutoKeyword(x)
  choice ...[x, `pluto_${x}`]

function anyAmountOf()
  repeat seq ...arguments
