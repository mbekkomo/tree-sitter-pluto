"civet autoConst"

enum Precedence
  Comma = -1
  Function = 1
  Default = 1
  Priority

  Or          // L -> or ??
  And         // L -> and
  Cmp         // L -> == ~= != < > <= >= ~= == <=> instanceof
  Bor         // L -> |
  Bxor        // L -> ~
  Band        // L -> &
  Bshift      // L -> << >>
  Concat      // R -> ..
  Arith       // L -> + -
  ArithDiv    // L -> * / // %
  Unary       // L -> not ! # + - ~
  Power       // R -> ^
  In          // L -> in

  Statement
  Program

module.exports = grammar
  name: "pluto"

  extras: => []
    /[\n]/
    /\s/
  
  rules:
    chunk: ($) => $._expression

    _expression: ($) => choice
      $.nil,
      $.boolean,
      $.number,
      $._prefix_expression,
      $.binary_operation,
      $.unary_operation,
      $.new_expression,
      $.increment_expression

    _prefix_expression: ($) => choice
      (seq "(", $._expression, ")")
  
    nil: => "nil"
    
    boolean: => choice "true", "false"

    /* from tree-sitter-lua, adjusted a lil bit */
    number: ($) =>
      decimal_digits = /[_0-9]+/
      signed_integer = seq (optional choice "-", "+"), decimal_digits
      decimal_exponent_part = seq (choice "e", "E"), signed_integer

      decimal_integer_literal = choice
        "0",
        seq (optional "0"), /[1-9]/, (optional decimal_digits)

      hex_digits = /[_a-fA-F0-9]+/
      hex_exponent_part = seq (choice "p", "P"), signed_integer

      bin_literal = seq
        (choice "0b", "0B"),
        /[_01]+/

      decimal_literal = choice
        (seq decimal_integer_literal,
             ".",
             (optional decimal_digits),
             (optional decimal_exponent_part)),
        (seq ".",
             decimal_digits,
             (optional decimal_exponent_part)),
        (seq decimal_integer_literal,
             (optional decimal_exponent_part))

      hex_literal = seq
        (choice "0x", "0X"),
        hex_digits,
        (optional seq ".", hex_digits),
        (optional hex_exponent_part)

      token choice decimal_literal, hex_literal, bin_literal

    binary_operation: ($) => choice
      ...([]
        ["or",  Precedence.Or]
        ["??",  Precedence.Or]
        ["and", Precedence.And]
        ["==",  Precedence.Cmp]
        ["~=",  Precedence.Cmp]
        ["!=",  Precedence.Cmp]
        ["<",   Precedence.Cmp]
        [">",   Precedence.Cmp]
        ["<=",  Precedence.Cmp]
        [">=",  Precedence.Cmp]
        ["<=>", Precedence.Cmp]
        ["instanceof", Precedence.Cmp]
        ["|",  Precedence.Bor]
        ["~",  Precedence.Bxor]
        ["&",  Precedence.Band]
        ["<<", Precedence.Bshift]
        [">>", Precedence.Bshift]
        ["+",  Precedence.Arith]
        ["-",  Precedence.Arith]
        ["*",  Precedence.ArithDiv]
        ["/",  Precedence.ArithDiv]
        ["//", Precedence.ArithDiv]
        ["%",  Precedence.ArithDiv  ]
        ["in", Precedence.In]
      ).map precedence $, "left"
      ...([]
        ["..", Precedence.Concat]
        ["^", Precedence.Power]
      ).map precedence $, "right"

    unary_operation: ($) =>
      prec.left Precedence.Unary, seq (choice
        "not",
        "!",
        "#",
        "+",
        "-",
        "~"
      ), $._expression

    new_expression: ($) => seq (plutoKeyword2 "new"), $._expression

    increment_expression: ($) => seq "++", /\w+/

function precedence($, x)
  [op, preced] => prec[x] preced, seq $._expression, op, $._expression

function plutoKeyword1(x)
  [x, `pluto_${x}`]

function plutoKeyword2(x)
  choice ...plutoKeyword1 x
